name: Create Release

on:
  push:
    tags:
      - 'v*'  # Matches v1.0.0, v1.0.1, v2.0.0, etc.

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for changelog
          ref: ${{ github.ref }}  # Checkout the tag that triggered the workflow

      - name: Extract version from tag
        id: tag
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "version=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Release version: $TAG_NAME"

      - name: Generate release notes from CHANGELOG
        id: changelog
        run: |
          CHANGELOG_FILE="commands/CHANGELOG.md"
          VERSION=${GITHUB_REF#refs/tags/v}

          if [ -f "$CHANGELOG_FILE" ]; then
            # Extract the section for this version from CHANGELOG.md
            # Looks for heading like "## [1.0.0]" or "## [v1.0.0]"
            # Stops at next version heading or end of file
            SECTION=$(awk -v version="$VERSION" '
              /^## \[/ && found { exit }
              /^## \[.*version.*\]/ { found=1 }
              found { print }
            ' "$CHANGELOG_FILE")

            if [ -n "$SECTION" ]; then
              echo "notes<<EOF" >> $GITHUB_OUTPUT
              echo "$SECTION" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              # Fallback: use tag message or default
              echo "notes=Release $VERSION - See CHANGELOG.md for details" >> $GITHUB_OUTPUT
            fi
          else
            # No changelog, use tag message or default
            TAG_MESSAGE=$(git tag -l --format='%(contents)' "${GITHUB_REF#refs/tags/}" 2>/dev/null || echo "")
            if [ -n "$TAG_MESSAGE" ]; then
              echo "notes=$TAG_MESSAGE" >> $GITHUB_OUTPUT
            else
              echo "notes=Release ${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Create commands archives
        id: archive
        run: |
          set -e
          TAG_NAME=${GITHUB_REF#refs/tags/}
          TAR_NAME="commands-${TAG_NAME}.tar.gz"
          ZIP_NAME="commands-${TAG_NAME}.zip"

          if [ ! -d "commands" ]; then
            echo "Error: commands folder not found"
            exit 1
          fi

          tar -czf "$TAR_NAME" -C commands .
          if [ ! -f "$TAR_NAME" ]; then
            echo "Error: Failed to create $TAR_NAME"
            exit 1
          fi

          cd commands
          zip -r "../$ZIP_NAME" . > /dev/null
          cd ..
          if [ ! -f "$ZIP_NAME" ]; then
            echo "Error: Failed to create $ZIP_NAME"
            exit 1
          fi

          echo "tar_name=$TAR_NAME" >> $GITHUB_OUTPUT
          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        id: release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          body: ${{ steps.changelog.outputs.notes }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          TAR_NAME="${{ steps.archive.outputs.tar_name }}"
          ZIP_NAME="${{ steps.archive.outputs.zip_name }}"

          gh release upload "$TAG_NAME" "$TAR_NAME" "$ZIP_NAME" --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Remove auto-generated source archives
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          VERSION="${TAG_NAME#v}"

          # GitHub creates source archives with names like: repo-name-version.tar.gz
          # Match assets that start with repo-name-version and end with .tar.gz or .zip
          # but exclude our custom archives (commands-*.tar.gz and commands-*.zip)

          # Get all assets and filter for source archives
          ASSETS_JSON=$(gh release view "$TAG_NAME" --json assets 2>/dev/null || echo '{"assets":[]}')

          # Extract asset names matching the pattern, excluding our custom archives
          SOURCE_ARCHIVES=$(echo "$ASSETS_JSON" | jq -r --arg repo "$REPO_NAME" --arg version "$VERSION" \
            '.assets[] | select(.name | startswith($repo + "-" + $version) and (.name | endswith(".tar.gz") or .name | endswith(".zip")) and (.name | startswith("commands-") | not)) | .name' 2>/dev/null || echo "")

          if [ -n "$SOURCE_ARCHIVES" ]; then
            echo "Found source archives to remove:"
            echo "$SOURCE_ARCHIVES"
            echo ""
            # Process each asset name (handle case where last line doesn't end with newline)
            echo "$SOURCE_ARCHIVES" | while IFS= read -r asset || [ -n "$asset" ]; do
              [ -z "$asset" ] && continue
              echo "Removing source archive: $asset"
              if gh release delete-asset "$TAG_NAME" "$asset" --yes 2>&1; then
                echo "✓ Successfully removed: $asset"
              else
                echo "✗ Failed to remove: $asset (may not exist or already removed)"
              fi
            done
          else
            echo "No auto-generated source archives found to remove"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout main for documentation update
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure git for documentation commit
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update releases documentation
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          VERSION=${TAG_NAME#v}
          RELEASE_DATE=$(date +"%Y-%m-%d")
          REPO="${{ github.repository }}"
          RELEASE_URL="https://github.com/${REPO}/releases/tag/${TAG_NAME}"

          # Create release entry markdown
          cat > /tmp/release_entry.txt << RELEASE_EOF
          ## [${TAG_NAME}](${RELEASE_URL}) - ${RELEASE_DATE}

          **[Download](${RELEASE_URL})** | [Release Notes](${RELEASE_URL})

          RELEASE_EOF

          # Use Python to update the releases.md file
          python3 << 'PYTHON_EOF'
          import re
          import sys

          releases_file = 'docs/releases.md'
          release_entry_file = '/tmp/release_entry.txt'

          try:
              # Read release entry
              with open(release_entry_file, 'r') as f:
                  release_entry = f.read()

              # Extract tag name from release entry (e.g., "v1.0.0" from "## [v1.0.0](...)")
              tag_match = re.search(r'## \[([^\]]+)\]', release_entry)
              tag_name = tag_match.group(1) if tag_match else ''

              # Read releases.md
              with open(releases_file, 'r') as f:
                  content = f.read()

              # Update Latest Release section
              # Replace from "## Latest Release" through the first "---" (handles empty or existing content)
              latest_pattern = r'(## Latest Release\n)\n*(---)'
              content = re.sub(latest_pattern, r'\1\n' + release_entry.strip() + r'\n\n\2', content)

              # Handle Release History section
              # First, check if the section exists, if not create it after Latest Release section
              if '## Release History' not in content:
                  # Insert Release History section after the first "---" (after Latest Release)
                  # Pattern: "---\n\n## [next section]" or "---\n\n## Download" etc.
                  history_insert_pattern = r'(\n---\n\n)(## (?!Release History))'
                  if re.search(history_insert_pattern, content):
                      # Insert before the next section (Download, Installation, Changelog, etc.)
                      content = re.sub(history_insert_pattern, r'\1## Release History\n\n' + release_entry + r'\2', content, flags=re.DOTALL)
                  else:
                      # No next section found, append before final "---" or at end
                      if content.rstrip().endswith('---'):
                          content = content.rstrip()[:-3] + '\n\n## Release History\n\n' + release_entry + '\n---'
                      else:
                          content = content.rstrip() + '\n\n## Release History\n\n' + release_entry
              else:
                  # Section exists. Remove duplicate for this tag only from Release History
                  # (never from Latest Release, or we would wipe Latest)
                  if tag_name:
                      escaped_tag = re.escape(tag_name)
                      duplicate_pattern = r'## \[{}\]\([^\)]+\) - [^\n]+\n\n\*\*\[Download\]\([^\)]+\)\*\* \| \[Release Notes\]\([^\)]+\)\n\n'.format(escaped_tag)
                      hist_start = content.find('## Release History')
                      if hist_start != -1:
                          hist_rest = content[hist_start + 1:]
                          mm = re.search(r'\n(## (?!\[)|---)', hist_rest)
                          hist_end = hist_start + 1 + mm.start() if mm else len(content)
                          hist_section = content[hist_start:hist_end]
                          hist_section = re.sub(duplicate_pattern, '', hist_section, flags=re.MULTILINE)
                          content = content[:hist_start] + hist_section + content[hist_end:]

                  # Add to Release History section - insert after heading
                  history_pattern = r'(## Release History\n\n)'
                  entry = release_entry.strip() + '\n\n'
                  history_replacement = r'\1' + entry
                  content = re.sub(history_pattern, history_replacement, content, flags=re.DOTALL)

              # Write back
              with open(releases_file, 'w') as f:
                  f.write(content)

              print("Successfully updated releases.md")
          except Exception as e:
              print(f"Error updating releases.md: {e}", file=sys.stderr)
              sys.exit(1)
          PYTHON_EOF

      - name: Commit documentation updates
        run: |
          git add docs/releases.md
          if ! git diff --staged --quiet; then
            git commit -m "docs: Add release ${{ github.ref_name }} to releases page"
            git push origin main
          else
            echo "No changes to commit"
          fi

  deploy-docs:
    needs: create-release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pages: write
      id-token: write
    concurrency:
      group: "pages"
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt

      - name: Build MkDocs site
        run: mkdocs build --strict

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: ./site

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
