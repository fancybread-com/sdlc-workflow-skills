name: Create Release

on:
  push:
    tags:
      - 'v*'  # Matches v1.0.0, v1.0.1, v2.0.0, etc.

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for changelog
          ref: main  # Checkout main branch for documentation updates

      - name: Extract version from tag
        id: tag
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "version=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Release version: $TAG_NAME"

      - name: Generate release notes from CHANGELOG
        id: changelog
        run: |
          CHANGELOG_FILE="implementations/cursor/commands/CHANGELOG.md"
          VERSION=${GITHUB_REF#refs/tags/v}

          if [ -f "$CHANGELOG_FILE" ]; then
            # Extract the section for this version from CHANGELOG.md
            # Looks for heading like "## [1.0.0]" or "## [v1.0.0]"
            # Stops at next version heading or end of file
            SECTION=$(awk -v version="$VERSION" '
              /^## \[/ && found { exit }
              /^## \[.*version.*\]/ { found=1 }
              found { print }
            ' "$CHANGELOG_FILE")

            if [ -n "$SECTION" ]; then
              echo "notes<<EOF" >> $GITHUB_OUTPUT
              echo "$SECTION" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              # Fallback: use tag message or default
              echo "notes=Release $VERSION - See CHANGELOG.md for details" >> $GITHUB_OUTPUT
            fi
          else
            # No changelog, use tag message or default
            TAG_MESSAGE=$(git tag -l --format='%(contents)' "${GITHUB_REF#refs/tags/}" 2>/dev/null || echo "")
            if [ -n "$TAG_MESSAGE" ]; then
              echo "notes=$TAG_MESSAGE" >> $GITHUB_OUTPUT
            else
              echo "notes=Release ${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Create implementations archives
        id: archive
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          TAR_NAME="commands-${TAG_NAME}.tar.gz"
          ZIP_NAME="commands-${TAG_NAME}.zip"

          # Create tar.gz archive with contents of implementations folder (not the folder itself)
          tar -czf "$TAR_NAME" -C implementations .

          # Create zip archive with contents of implementations folder (not the folder itself)
          cd implementations
          zip -r "../$ZIP_NAME" .
          cd ..

          echo "tar_name=$TAR_NAME" >> $GITHUB_OUTPUT
          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT
          echo "Created archives: $TAR_NAME and $ZIP_NAME"

      - name: Create GitHub Release
        id: release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          body: ${{ steps.changelog.outputs.notes }}
          files: ${{ steps.archive.outputs.tar_name }} ${{ steps.archive.outputs.zip_name }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update releases documentation
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          VERSION=${TAG_NAME#v}
          RELEASE_DATE=$(date +"%Y-%m-%d")
          REPO="${{ github.repository }}"
          RELEASE_URL="https://github.com/${REPO}/releases/tag/${TAG_NAME}"

          # Create release entry markdown
          cat > /tmp/release_entry.txt << RELEASE_EOF
          ## [${TAG_NAME}](${RELEASE_URL}) - ${RELEASE_DATE}

          **[Download](${RELEASE_URL})** | [Release Notes](${RELEASE_URL})

          RELEASE_EOF

          # Use Python to update the releases.md file
          python3 << 'PYTHON_EOF'
          import re

          releases_file = 'docs/releases.md'
          release_entry_file = '/tmp/release_entry.txt'

          # Read release entry
          with open(release_entry_file, 'r') as f:
              release_entry = f.read()

          # Extract tag name from release entry (e.g., "v1.0.0" from "## [v1.0.0](...)")
          tag_match = re.search(r'## \[([^\]]+)\]', release_entry)
          tag_name = tag_match.group(1) if tag_match else ''

          # Read releases.md
          with open(releases_file, 'r') as f:
              content = f.read()

          # Update Latest Release section - replace comment with actual release entry
          latest_pattern = r'(## Latest Release\n\n)(<!--.*?-->\n\n)(---)'
          latest_replacement = r'\1' + release_entry + r'\3'
          content = re.sub(latest_pattern, latest_replacement, content, flags=re.DOTALL)

          # Handle Release History section
          # First, remove any existing entries for this tag to prevent duplicates
          if tag_name:
              # Pattern to match a release entry (from ## to next ## or ---)
              # Matches: ## [tag_name](url) - date\n\n**[Download](url)** | [Release Notes](url)\n\n
              escaped_tag = re.escape(tag_name)
              duplicate_pattern = r'## \[{}\]\([^\)]+\) - [^\n]+\n\n\*\*\[Download\]\([^\)]+\)\*\* \| \[Release Notes\]\([^\)]+\)\n\n'.format(escaped_tag)
              content = re.sub(duplicate_pattern, '', content, flags=re.MULTILINE)

          # Add to Release History section - insert after heading, before existing entries
          history_pattern = r'(## Release History\n\n)(<!--.*?-->\n\n)'
          if not re.search(history_pattern, content, re.DOTALL):
              # No comment, just heading
              history_pattern = r'(## Release History\n\n)'
          history_replacement = r'\1' + release_entry
          content = re.sub(history_pattern, history_replacement, content, flags=re.DOTALL)

          # Write back
          with open(releases_file, 'w') as f:
              f.write(content)
          PYTHON_EOF

      - name: Commit documentation updates
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/releases.md
          if ! git diff --staged --quiet; then
            git commit -m "docs: Add release ${{ github.ref_name }} to releases page"
            git push origin main
          else
            echo "No changes to commit"
          fi

  deploy-docs:
    needs: create-release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pages: write
      id-token: write
    concurrency:
      group: "pages"
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt

      - name: Build MkDocs site
        run: mkdocs build --strict

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: ./site

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
