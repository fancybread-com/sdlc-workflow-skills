name: Create Release

on:
  push:
    tags:
      - 'v*'  # Matches v1.0.0, v1.0.1, v2.0.0, etc.

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for changelog
          ref: ${{ github.ref }}  # Checkout the tag that triggered the workflow

      - name: Extract version from tag
        id: tag
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          echo "version=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Release version: $TAG_NAME"

      - name: Generate release notes from CHANGELOG
        id: changelog
        run: |
          CHANGELOG_FILE="commands/CHANGELOG.md"
          VERSION=${GITHUB_REF#refs/tags/v}

          if [ -f "$CHANGELOG_FILE" ]; then
            # Extract the section for this version from CHANGELOG.md
            # Looks for heading like "## [1.0.0]" or "## [v1.0.0]"
            # Stops at next version heading or end of file
            SECTION=$(awk -v version="$VERSION" '
              /^## \[/ && found { exit }
              /^## \[.*version.*\]/ { found=1 }
              found { print }
            ' "$CHANGELOG_FILE")

            if [ -n "$SECTION" ]; then
              echo "notes<<EOF" >> $GITHUB_OUTPUT
              echo "$SECTION" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            else
              # Fallback: use tag message or default
              echo "notes=Release $VERSION - See CHANGELOG.md for details" >> $GITHUB_OUTPUT
            fi
          else
            # No changelog, use tag message or default
            TAG_MESSAGE=$(git tag -l --format='%(contents)' "${GITHUB_REF#refs/tags/}" 2>/dev/null || echo "")
            if [ -n "$TAG_MESSAGE" ]; then
              echo "notes=$TAG_MESSAGE" >> $GITHUB_OUTPUT
            else
              echo "notes=Release ${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Create commands archives
        id: archive
        run: |
          set -e
          TAG_NAME=${GITHUB_REF#refs/tags/}
          TAR_NAME="commands-${TAG_NAME}.tar.gz"
          ZIP_NAME="commands-${TAG_NAME}.zip"

          if [ ! -d "commands" ]; then
            echo "Error: commands folder not found"
            exit 1
          fi

          # Package with top-level commands/ so "cp -r commands/* ~/.cursor/commands/" works after extract
          mkdir -p release-package
          cp -r commands release-package/

          tar -czf "$TAR_NAME" -C release-package .
          if [ ! -f "$TAR_NAME" ]; then
            echo "Error: Failed to create $TAR_NAME"
            exit 1
          fi

          cd release-package
          zip -r "../$ZIP_NAME" . > /dev/null
          cd ..
          if [ ! -f "$ZIP_NAME" ]; then
            echo "Error: Failed to create $ZIP_NAME"
            exit 1
          fi

          rm -rf release-package

          echo "tar_name=$TAR_NAME" >> $GITHUB_OUTPUT
          echo "zip_name=$ZIP_NAME" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        id: release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ github.ref_name }}
          body: ${{ steps.changelog.outputs.notes }}
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload release assets
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          TAR_NAME="${{ steps.archive.outputs.tar_name }}"
          ZIP_NAME="${{ steps.archive.outputs.zip_name }}"

          gh release upload "$TAG_NAME" "$TAR_NAME" "$ZIP_NAME" --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Remove auto-generated source archives
        run: |
          TAG_NAME=${GITHUB_REF#refs/tags/}
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          VERSION="${TAG_NAME#v}"

          # GitHub creates source archives with names like: repo-name-version.tar.gz
          # Match assets that start with repo-name-version and end with .tar.gz or .zip
          # but exclude our custom archives (commands-*.tar.gz and commands-*.zip)

          # Get all assets and filter for source archives
          ASSETS_JSON=$(gh release view "$TAG_NAME" --json assets 2>/dev/null || echo '{"assets":[]}')

          # Extract asset names matching the pattern, excluding our custom archives
          SOURCE_ARCHIVES=$(echo "$ASSETS_JSON" | jq -r --arg repo "$REPO_NAME" --arg version "$VERSION" \
            '.assets[] | select(.name | startswith($repo + "-" + $version) and (.name | endswith(".tar.gz") or .name | endswith(".zip")) and (.name | startswith("commands-") | not)) | .name' 2>/dev/null || echo "")

          if [ -n "$SOURCE_ARCHIVES" ]; then
            echo "Found source archives to remove:"
            echo "$SOURCE_ARCHIVES"
            echo ""
            # Process each asset name (handle case where last line doesn't end with newline)
            echo "$SOURCE_ARCHIVES" | while IFS= read -r asset || [ -n "$asset" ]; do
              [ -z "$asset" ] && continue
              echo "Removing source archive: $asset"
              if gh release delete-asset "$TAG_NAME" "$asset" --yes 2>&1; then
                echo "✓ Successfully removed: $asset"
              else
                echo "✗ Failed to remove: $asset (may not exist or already removed)"
              fi
            done
          else
            echo "No auto-generated source archives found to remove"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout main for documentation update
        uses: actions/checkout@v4
        with:
          ref: main
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Configure git for documentation commit
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update releases documentation
        env:
          TAG_NAME: ${{ github.ref_name }}
          RELEASE_URL: https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }}
        run: |
          python3 << 'PYTHON_EOF'
          import os
          import re
          import sys
          from datetime import datetime, timezone

          tag_name = os.environ.get('TAG_NAME', '')
          release_url = os.environ.get('RELEASE_URL', '')
          release_date = datetime.now(timezone.utc).strftime('%Y-%m-%d')
          release_entry = (
              f"## [{tag_name}]({release_url}) - {release_date}\n\n"
              f"[**Download**]({release_url}) | [Release Notes]({release_url})\n"
          )

          releases_file = 'docs/releases.md'

          try:
              with open(releases_file, 'r') as f:
                  content = f.read()

              latest_pattern = r'(## Latest Release\n\n).*?(\n+---)'
              new_content = re.sub(latest_pattern, r'\1' + release_entry.strip() + r'\n\n---', content, flags=re.DOTALL)
              if new_content == content:
                  print("Warning: Latest Release pattern did not match; section may be unchanged.", file=sys.stderr)
              content = new_content

              if '## Release History' not in content:
                  pat = r'(\n---\n\n)(## (?!Release History))'
                  if re.search(pat, content):
                      content = re.sub(pat, r'\1## Release History\n\n' + release_entry.strip() + '\n\n' + r'\2', content, flags=re.DOTALL)
                  else:
                      tail = content.rstrip()
                      content = (tail[:-3] if tail.endswith('---') else tail) + '\n\n## Release History\n\n' + release_entry.strip() + '\n\n---'
              else:
                  if tag_name:
                      esc = re.escape(tag_name)
                      dup = r'## \[{}\]\([^\)]+\) - [^\n]+\n\n[^\n]+\[Release Notes\][^\n]+\n\n'.format(esc)
                      start = content.find('## Release History')
                      if start != -1:
                          rest = content[start + 1:]
                          m = re.search(r'\n(## (?!\[)|---)', rest)
                          end = start + 1 + (m.start() if m else len(rest))
                          hist = re.sub(dup, '', content[start:end], flags=re.MULTILINE)
                          content = content[:start] + hist + content[end:]
                  content = re.sub(r'(## Release History\n\n)', r'\1' + release_entry.strip() + '\n\n', content, count=1)

              content = re.sub(latest_pattern, r'\1' + release_entry.strip() + r'\n\n---', content, flags=re.DOTALL)

              with open(releases_file, 'w') as f:
                  f.write(content)

              print("Successfully updated releases.md")
          except Exception as e:
              print(f"Error updating releases.md: {e}", file=sys.stderr)
              sys.exit(1)
          PYTHON_EOF

      - name: Commit documentation updates
        run: |
          git add docs/releases.md
          if ! git diff --staged --quiet; then
            git commit -m "docs: Add release ${{ github.ref_name }} to releases page"
            git push origin main
          else
            echo "No changes to commit"
          fi

  deploy-docs:
    needs: create-release
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pages: write
      id-token: write
    concurrency:
      group: "pages"
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main  # Checkout main to get the updated releases.md from create-release job
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Install dependencies
        run: |
          pip install --upgrade pip
          pip install -r requirements.txt

      - name: Build MkDocs site
        run: mkdocs build --strict

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: ./site

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
